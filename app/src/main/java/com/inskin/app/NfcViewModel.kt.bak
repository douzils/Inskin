package com.inskin.app

import android.app.Application
import android.nfc.NdefMessage
import android.nfc.NdefRecord
import android.nfc.Tag
import android.nfc.tech.Ndef
import android.nfc.tech.NdefFormatable
import android.nfc.tech.NfcA
import android.nfc.tech.MifareUltralight
import androidx.lifecycle.AndroidViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.io.IOException

class NfcViewModel(application: Application) : AndroidViewModel(application) {
    private var lastTag: Tag? = null

    private val _tagInfo = MutableStateFlow<TagInfo?>(null)
    val tagInfo = _tagInfo.asStateFlow()

    fun updateFromTag(tag: Tag) {
        lastTag = tag

        val ndef = Ndef.get(tag)
        val ndefPresent = (ndef != null)
        val ndefMax = ndef?.maxSize ?: 0
        val ndefUsed = ndef?.cachedNdefMessage?.toByteArray()?.size ?: 0
        val writable = ndef?.isWritable == true
        val readonly = ndef?.isWritable == false

        val nfcA = NfcA.get(tag)
        val atqa = nfcA?.atqa?.joinToString("") { "%02X".format(it) }?.let { "0x$it" }
        val sak  = nfcA?.sak?.let { "0x%02X".format(it) }

        val mu = MifareUltralight.get(tag)
        val estCap = when (mu?.type) {
            MifareUltralight.TYPE_ULTRALIGHT      -> 48
            MifareUltralight.TYPE_ULTRALIGHT_C    -> 144
            MifareUltralight.TYPE_NTAG213         -> 144
            MifareUltralight.TYPE_NTAG215         -> 504
            MifareUltralight.TYPE_NTAG216         -> 888
            else -> 0
        }

        val isoType = when {
            mu != null -> "NFC Forum Type 2"
            nfcA != null && ndefPresent -> "ISO 14443-3A (NFC-A)"
            else -> null
        }

        val techs = tag.techList.map { it.substringAfterLast('.') }
        val formatable = (NdefFormatable.get(tag) != null)
        val uid: String? = tag.id?.joinToString("") { "%02X".format(it) }

        _tagInfo.value = TagInfo(
            type = ndef?.type,
            techs = techs,
            uid = uid,
            atqa = atqa,
            sak = sak,
            size = if (ndefMax > 0) ndefMax else estCap,
            used = ndefUsed,
            writable = writable,
            readonly = readonly,
            records = emptyList(),
            isoType = isoType,
            ndefPresent = ndefPresent,
            formatable = formatable
        )
    }

    fun writeTextNdef(text: String): Result<Unit> = runCatching {
        val tag = lastTag ?: error("No tag")
        val ndef = Ndef.get(tag) ?: error("Tag is not NDEF")
        ndef.connect()
        val record = NdefRecord.createTextRecord("", text)
        val message = NdefMessage(arrayOf(record))
        ensureCapacity(ndef, message)
        ndef.writeNdefMessage(message)
        ndef.close()
    }

    fun writeUrlNdef(url: String): Result<Unit> = runCatching {
        val tag = lastTag ?: error("No tag")
        val ndef = Ndef.get(tag) ?: error("Tag is not NDEF")
        ndef.connect()
        val record = NdefRecord.createUri(url)
        val message = NdefMessage(arrayOf(record))
        ensureCapacity(ndef, message)
        ndef.writeNdefMessage(message)
        ndef.close()
    }

    private fun ensureCapacity(ndef: Ndef, message: NdefMessage) {
        val bytes = message.toByteArray()
        if (ndef.maxSize < bytes.size) {
            ndef.close()
            throw IOException("Tag capacity ${ndef.maxSize} < ${bytes.size}")
        }
        if (!ndef.isWritable) {
            ndef.close()
            throw IOException("Tag is read-only")
        }
    }
}
